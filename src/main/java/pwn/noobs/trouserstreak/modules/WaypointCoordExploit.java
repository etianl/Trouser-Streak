package pwn.noobs.trouserstreak.modules;

import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.systems.waypoints.Waypoints;
import meteordevelopment.meteorclient.systems.waypoints.Waypoint;
import meteordevelopment.meteorclient.utils.player.PlayerUtils;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.client.network.PlayerListEntry;
import net.minecraft.text.Text;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;
import net.minecraft.world.waypoint.TrackedWaypoint;
import pwn.noobs.trouserstreak.Trouser;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class WaypointCoordExploit extends Module {
    private final SettingGroup sgGeneral = settings.getDefaultGroup();
    public enum OutputMode { CHAT, HUD }

    private final Setting<OutputMode> outputMode = sgGeneral.add(new EnumSetting.Builder<OutputMode>()
            .name("output-mode")
            .description("How to display triangulated positions.")
            .defaultValue(OutputMode.CHAT)
            .build()
    );

    private final Setting<Boolean> createWaypoints = sgGeneral.add(new BoolSetting.Builder()
            .name("create-waypoints")
            .description("Create Meteor waypoints for triangulated player positions.")
            .defaultValue(true)
            .build()
    );

    private final Setting<Double> minDelta = sgGeneral.add(new DoubleSetting.Builder()
            .name("Minimum sample delta (degrees)")
            .description("The minimum delta required between packet samples for an output.")
            .sliderRange(0,360)
            .defaultValue(1)
            .build()
    );
    private final Setting<Integer> minMove = sgGeneral.add(new IntSetting.Builder()
            .name("Minimum move distance")
            .description("Minimum distance you must move to record a new sample.")
            .sliderRange(0, 100)
            .defaultValue(20)
            .build()
    );

    private final Map<UUID, String> uuidToName = new ConcurrentHashMap<>();
    private final Map<UUID, Waypoint> playerWaypoints = new ConcurrentHashMap<>();

    private static class TriangulationSamples {
        public Vec3d position1;
        public Vec3d position2;
        public float azi1 = Float.NaN;
        public float azi2 = Float.NaN;
    }
    private final Map<UUID, TriangulationSamples> triangulations = new ConcurrentHashMap<>();

    public static class TriangulationResult {
        public double wx, wz;
        public String playerName;
        public long lastUpdated;

        public TriangulationResult(double wx, double wz, String playerName) {
            this.wx = wx;
            this.wz = wz;
            this.playerName = playerName;
            this.lastUpdated = System.currentTimeMillis();
        }
    }

    public static final Map<UUID, TriangulationResult> lastResults = new ConcurrentHashMap<>();
    public static Map<UUID, TriangulationResult> getLastResults() { return lastResults; }

    public WaypointCoordExploit() {
        super(Trouser.baseHunting, "WaypointCoordExploit", "Triangulate player locations with the new waypoint system introduced in Minecraft 1.21.6.");
    }

    @Override
    public void onActivate() {
        triangulations.clear();
        lastResults.clear();
        uuidToName.clear();
        playerWaypoints.clear();
    }

    @Override
    public void onDeactivate() {
        triangulations.clear();
        lastResults.clear();
        uuidToName.clear();
        playerWaypoints.clear();
    }

    private void addOrUpdateWaypoint(UUID uuid, String playerName, double wx, double wz) {
        if (!createWaypoints.get() || mc == null || mc.world == null || mc.getNetworkHandler() == null) return;

        String wpName = playerName + " (WP Exploit)";

        Waypoints waypoints = Waypoints.get();
        Waypoint existing = playerWaypoints.get(uuid);

        if (existing != null) {
            for (Waypoint wp : waypoints) {
                if (wp == existing) {
                    BlockPos newPos = new BlockPos((int) Math.floor(wx), mc.player.getBlockY(), (int) Math.floor(wz));
                    existing.pos.set(newPos);
                    existing.name.set(wpName);
                    waypoints.save();
                    return;
                }
            }
            playerWaypoints.remove(uuid);
        }

        BlockPos newPos = new BlockPos((int) Math.floor(wx), mc.player.getBlockY(), (int) Math.floor(wz));
        Waypoint waypoint = new Waypoint.Builder()
                .name(wpName)
                .pos(newPos)
                .dimension(PlayerUtils.getDimension())
                .build();

        waypoints.add(waypoint);
        playerWaypoints.put(uuid, waypoint);
        waypoints.save();
    }

    @EventHandler
    private void onPreTick(TickEvent.Pre event) {
        if (mc.getNetworkHandler() != null && mc.getNetworkHandler().getPlayerList() != null) {
            for (PlayerListEntry entry : mc.getNetworkHandler().getPlayerList()) {
                UUID uuid = entry.getProfile().id();
                if (uuid != null) {
                    Text displayName = entry.getDisplayName();
                    String name = displayName != null ? displayName.getString() : entry.getProfile().name();

                    if (name != null && !name.isEmpty()) {
                        uuidToName.put(uuid, name);
                    }
                }
            }
        }

        mc.getNetworkHandler().getWaypointHandler().forEachWaypoint(mc.player, waypoint -> {
            UUID currentUuid = waypoint.getSource().left().orElse(null);
            if (currentUuid == null) return;

            if (waypoint instanceof TrackedWaypoint.Positional posWaypoint) {
                Vec3i pos = posWaypoint.pos;
                double wx = pos.getX();
                double wz = pos.getZ();

                String playerName = uuidToName.getOrDefault(currentUuid, currentUuid.toString());
                TriangulationResult result = new TriangulationResult(wx, wz, playerName);
                lastResults.put(currentUuid, result);

                addOrUpdateWaypoint(currentUuid, playerName, wx, wz);

                if (outputMode.get() == OutputMode.CHAT) {
                    if (chatFeedback)info(Text.of("Direct position for " + playerName + ": (" + wx + ", " + wz + ")"));
                }
                return;
            }
            if (!(waypoint instanceof TrackedWaypoint.Azimuth azimuthWaypoint)) return;

            TriangulationSamples samples = triangulations.computeIfAbsent(currentUuid, k -> new TriangulationSamples());

            if (Float.isNaN(samples.azi1)) {
                samples.azi1 = azimuthWaypoint.azimuth;
                samples.position1 = new Vec3d(mc.player.getX(), mc.player.getY(), mc.player.getZ());
            } else if (Float.isNaN(samples.azi2)) {
                Vec3d current = new Vec3d(mc.player.getX(), mc.player.getY(), mc.player.getZ());
                if (samples.position1 != null && current.distanceTo(samples.position1) < minMove.get()) {
                    return;
                }
                float angleDelta = Math.abs(samples.azi1 - azimuthWaypoint.azimuth);
                double angleDeltaDegrees = Math.toDegrees(angleDelta);
                if (angleDeltaDegrees > minDelta.get()) {
                    samples.azi2 = azimuthWaypoint.azimuth;
                    samples.position2 = current;
                }
            }
        });
        for (Map.Entry<UUID, TriangulationSamples> entry : triangulations.entrySet()) {
            UUID uuid = entry.getKey();
            TriangulationSamples samples = entry.getValue();

            if (!Float.isNaN(samples.azi1) && !Float.isNaN(samples.azi2)
                    && samples.position1 != null && samples.position2 != null) {

                double x1 = samples.position1.getX();
                double z1 = samples.position1.getZ();
                double x2 = samples.position2.getX();
                double z2 = samples.position2.getZ();

                double dx1 = -Math.sin(samples.azi1);
                double dz1 =  Math.cos(samples.azi1);
                double dx2 = -Math.sin(samples.azi2);
                double dz2 =  Math.cos(samples.azi2);

                double denominator = dx1 * dz2 - dz1 * dx2;
                if (Math.abs(denominator) < 1e-8) {
                    if (chatFeedback)error("Lines are parallel; cannot triangulate for " + uuidToName.getOrDefault(uuid, uuid.toString()));
                    samples.azi1 = Float.NaN;
                    samples.azi2 = Float.NaN;
                    samples.position1 = null;
                    samples.position2 = null;
                    continue;
                }
                double t = ((x2 - x1) * dz2 - (z2 - z1) * dx2) / denominator;
                double wx = x1 + t * dx1;
                double wz = z1 + t * dz1;

                String playerName = uuidToName.getOrDefault(uuid, uuid.toString());

                TriangulationResult result = new TriangulationResult(wx, wz, playerName);
                lastResults.put(uuid, result);

                addOrUpdateWaypoint(uuid, playerName, wx, wz);

                if (outputMode.get() == OutputMode.CHAT) {
                    if (chatFeedback)info(Text.of("Estimated position for " + playerName + ": (" + wx + ", " + wz + ")"));
                }

                samples.azi1 = Float.NaN;
                samples.azi2 = Float.NaN;
                samples.position1 = null;
                samples.position2 = null;
            }
        }
    }
}
// made by etianl :D
package pwn.noobs.trouserstreak.modules;

import meteordevelopment.meteorclient.events.packets.PacketEvent;
import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.utils.player.ChatUtils;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.network.packet.s2c.play.PlayerListS2CPacket;
import net.minecraft.network.packet.s2c.play.WaypointS2CPacket;
import net.minecraft.text.Text;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.waypoint.TrackedWaypoint;
import pwn.noobs.trouserstreak.Trouser;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class WaypointCoordExploit extends Module {
    private final SettingGroup sgGeneral = settings.getDefaultGroup();
    public enum OutputMode { CHAT, HUD }

    private final Setting<OutputMode> outputMode = sgGeneral.add(new EnumSetting.Builder<OutputMode>()
            .name("output-mode")
            .description("How to display triangulated positions.")
            .defaultValue(OutputMode.CHAT)
            .build()
    );
    private final Setting<Double> minDelta = sgGeneral.add(new DoubleSetting.Builder()
            .name("Minimum sample delta (degrees)")
            .description("The minimum delta required between packet samples for an output.")
            .sliderRange(0,360)
            .defaultValue(1)
            .build()
    );
    private final Setting<Double> minMove = sgGeneral.add(new DoubleSetting.Builder()
            .name("Minimum move distance")
            .description("Minimum distance you must move to record a new sample.")
            .sliderRange(0, 100)
            .defaultValue(15.0)
            .build()
    );

    private final Map<UUID, String> uuidToName = new ConcurrentHashMap<>();

    private static class TriangulationSamples {
        public Vec3d position1;
        public Vec3d position2;
        public float azi1 = Float.NaN;
        public float azi2 = Float.NaN;
    }
    private final Map<UUID, TriangulationSamples> triangulations = new ConcurrentHashMap<>();
    public static class TriangulationResult {
        public double wx, wz;
        public String playerName;
        public long lastUpdated;

        public TriangulationResult(double wx, double wz, String playerName) {
            this.wx = wx;
            this.wz = wz;
            this.playerName = playerName;
            this.lastUpdated = System.currentTimeMillis();
        }
    }

    public static final Map<UUID, TriangulationResult> lastResults = new ConcurrentHashMap<>();
    public static Map<UUID, TriangulationResult> getLastResults() { return lastResults; }
    public WaypointCoordExploit() {
        super(Trouser.baseHunting, "WaypointCoordExploit", "Triangulate player locations with the new waypoint system introduced in Minecraft 1.21.6.");
    }

    @Override
    public void onActivate() {
        triangulations.clear();
        lastResults.clear();
    }

    @Override
    public void onDeactivate() {
        triangulations.clear();
        lastResults.clear();
    }
    @EventHandler
    private void onPacketReceive(PacketEvent.Receive event) {
        if (event.packet instanceof PlayerListS2CPacket) {
            PlayerListS2CPacket packet = (PlayerListS2CPacket) event.packet;
            for (PlayerListS2CPacket.Entry entry : packet.getEntries()) {
                UUID uuid = entry.profileId();
                if (entry.profile() != null && entry.profile().name() != null) {
                    uuidToName.putIfAbsent(uuid, entry.profile().name());
                }
            }
        }

        if (event.packet instanceof WaypointS2CPacket) {
            WaypointS2CPacket packet = (WaypointS2CPacket) event.packet;
            TrackedWaypoint waypoint = packet.waypoint();

            if (waypoint instanceof TrackedWaypoint.Azimuth azimuthWaypoint) {
                String source = waypoint.getSource().toString();
                UUID currentUuid = null;
                for (UUID uuid : uuidToName.keySet()) {
                    if (source.contains(uuid.toString())) {
                        currentUuid = uuid;
                        break;
                    }
                }
                if (currentUuid == null) return;

                TriangulationSamples samples = triangulations.computeIfAbsent(currentUuid, k -> new TriangulationSamples());

                if (Float.isNaN(samples.azi1)) {
                    samples.azi1 = azimuthWaypoint.azimuth;
                    samples.position1 = new Vec3d(mc.player.getX(), mc.player.getY(), mc.player.getZ());
                } else if (Float.isNaN(samples.azi2)) {
                    Vec3d current = new Vec3d(mc.player.getX(), mc.player.getY(), mc.player.getZ());
                    if (samples.position1 != null && current.distanceTo(samples.position1) < minMove.get()) {
                        return;
                    }
                    float angleDelta = Math.abs(samples.azi1 - azimuthWaypoint.azimuth);
                    double angleDeltaDegrees = Math.toDegrees(angleDelta);
                    if (angleDeltaDegrees > minDelta.get()) {
                        samples.azi2 = azimuthWaypoint.azimuth;
                        samples.position2 = current;
                    }
                }
            }
        }
    }

    @EventHandler
    private void onPreTick(TickEvent.Pre event) {
        for (Map.Entry<UUID, TriangulationSamples> entry : triangulations.entrySet()) {
            UUID uuid = entry.getKey();
            TriangulationSamples samples = entry.getValue();

            if (!Float.isNaN(samples.azi1) && !Float.isNaN(samples.azi2)
                    && samples.position1 != null && samples.position2 != null) {

                double x1 = samples.position1.getX();
                double z1 = samples.position1.getZ();
                double x2 = samples.position2.getX();
                double z2 = samples.position2.getZ();

                double dx1 = -Math.sin(samples.azi1);
                double dz1 =  Math.cos(samples.azi1);
                double dx2 = -Math.sin(samples.azi2);
                double dz2 =  Math.cos(samples.azi2);

                double denominator = dx1 * dz2 - dz1 * dx2;
                if (Math.abs(denominator) < 1e-8) {
                    error("Lines are parallel; cannot triangulate for " + uuidToName.getOrDefault(uuid, uuid.toString()));
                    samples.azi1 = Float.NaN;
                    samples.azi2 = Float.NaN;
                    samples.position1 = null;
                    samples.position2 = null;
                    continue;
                }
                double t = ((x2 - x1) * dz2 - (z2 - z1) * dx2) / denominator;
                double wx = x1 + t * dx1;
                double wz = z1 + t * dz1;

                String playerName = uuidToName.getOrDefault(uuid, uuid.toString());

                TriangulationResult result = new TriangulationResult(wx, wz, playerName);
                lastResults.put(uuid, result);

                if (outputMode.get() == OutputMode.CHAT) {
                    ChatUtils.sendMsg(Text.of("Estimated position for " + playerName + ": (" + wx + ", " + wz + ")"));
                }

                samples.azi1 = Float.NaN;
                samples.azi2 = Float.NaN;
                samples.position1 = null;
                samples.position2 = null;
            }
        }
    }
}